package com.example.plshelp.android.data

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import com.google.firebase.Timestamp
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.Query
import com.google.firebase.firestore.ListenerRegistration
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.tasks.await
import java.util.Date // Keep java.util.Date for Timestamp.toDate()

enum class ChatType {
    ONE_ON_ONE,
    GROUP
}

class ChatViewModel(
    private val listingId: String,
    private val requestedParticipantIds: List<String>, // ALL intended participants for this chat
    private val currentUserId: String,
    private val currentUserName: String,
    private val chatType: ChatType // New parameter to determine chat behavior
) : ViewModel() {

    private val db = FirebaseFirestore.getInstance()
    private val _messages = MutableStateFlow<List<ChatMessage>>(emptyList())
    val messages: StateFlow<List<ChatMessage>> = _messages.asStateFlow()

    private val _isLoading = MutableStateFlow(true)
    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()

    private val _errorMessage = MutableStateFlow<String?>(null)
    val errorMessage: StateFlow<String?> = _errorMessage.asStateFlow()

    private val _listingTitle = MutableStateFlow<String?>("Loading...") // New StateFlow for listing title
    val listingTitle: StateFlow<String?> = _listingTitle.asStateFlow()

    private var chatDocumentId: String? = null // This will be the actual Firebase autogenerated ID
    private var messagesListener: ListenerRegistration? = null

    init {
        Log.d("ChatViewModel", "Initializing ChatViewModel for listing: $listingId, participants: $requestedParticipantIds, chatType: $chatType")
        viewModelScope.launch {
            fetchListingTitle() // Fetch listing title when ViewModel initializes
            findOrCreateChatDocument()
        }
    }

    private suspend fun fetchListingTitle() {
        try {
            val listingDoc = db.collection("listings").document(listingId).get().await()
            val title = listingDoc.getString("title")
            _listingTitle.value = title ?: "Unknown Listing"
            Log.d("ChatViewModel", "Fetched listing title: $_listingTitle.value for listingId: $listingId")
        } catch (e: Exception) {
            _listingTitle.value = "Error Loading Listing"
            Log.e("ChatViewModel", "Error fetching listing title for $listingId: ${e.message}", e)
        }
    }

    private suspend fun findOrCreateChatDocument() {
        _isLoading.value = true
        _errorMessage.value = null
        try {
            val chatsCollection = db.collection("chats")
            // Always sort participants for consistent querying and storage
            val sortedParticipants = requestedParticipantIds.sorted()

            val existingChatQuery = when (chatType) {
                ChatType.ONE_ON_ONE -> {
                    // For ONE_ON_ONE, the chat must be linked to a specific listing
                    // and contain only the two sorted participants, and be marked as not a group chat.
                    chatsCollection
                        .whereEqualTo("listingId", listingId) // Crucial for uniqueness per listing
                        .whereEqualTo("participants", sortedParticipants)
                        .whereEqualTo("isGroupChat", false)
                        .limit(1)
                }
                ChatType.GROUP -> {
                    // For GROUP chat, it's tied to the listing and must contain all requested participants.
                    var query = chatsCollection
                        .whereEqualTo("listingId", listingId)
                        .whereEqualTo("isGroupChat", true)

                    // Ensure all requested participants are in the group chat
                    sortedParticipants.forEach { participantId ->
                        query = query.whereArrayContains("participants", participantId)
                    }
                    query.limit(1) // Assuming only one group chat per listing with this exact set of initial participants
                }
            }

            val querySnapshot = existingChatQuery.get().await()

            if (!querySnapshot.isEmpty) {
                // Chat found!
                chatDocumentId = querySnapshot.documents.first().id
                Log.d("ChatViewModel", "Found existing chat with ID: $chatDocumentId")
                listenForMessages()
            } else {
                // No existing chat found, create a new one.
                Log.d("ChatViewModel", "No existing chat found, creating new one for listing: $listingId, participants: $requestedParticipantIds, chatType: $chatType")
                createNewChatDocument(sortedParticipants)
            }
        } catch (e: Exception) {
            _errorMessage.value = "Failed to find or create chat: ${e.message}"
            Log.e("ChatViewModel", "Error in findOrCreateChatDocument: ${e.message}", e)
            _isLoading.value = false
        }
    }

    private suspend fun createNewChatDocument(sortedParticipants: List<String>) {
        try {
            val newChatRef = db.collection("chats").document() // Firebase autogenerates ID
            chatDocumentId = newChatRef.id // Store the new autogenerated ID

            val newChatData = hashMapOf(
                "participants" to sortedParticipants,
                "listingId" to listingId, // Always include listingId for context
                "isGroupChat" to (chatType == ChatType.GROUP), // Set based on chatType
                "createdAt" to Timestamp.now(),
                "updatedAt" to Timestamp.now(),
                "lastMessage" to null // No last message yet
            )

            // The chatName can now be derived from the fetched listing title
            val currentListingTitle = _listingTitle.value
            if (currentListingTitle != null && currentListingTitle != "Loading..." && currentListingTitle != "Unknown Listing" && currentListingTitle != "Error Loading Listing") {
                newChatData["chatName"] = if (chatType == ChatType.GROUP) {
                    "$currentListingTitle Group Chat"
                } else {
                    "$currentListingTitle Chat"
                }
            } else {
                // Fallback if title not yet loaded or error
                newChatData["chatName"] = if (chatType == ChatType.GROUP) {
                    "Group Chat for Listing ID: $listingId"
                } else {
                    "Chat for Listing ID: $listingId"
                }
            }


            newChatRef.set(newChatData).await()
            Log.d("ChatViewModel", "New chat document created with ID: $chatDocumentId")
            listenForMessages() // Start listening to messages for the new chat
        } catch (e: Exception) {
            _errorMessage.value = "Failed to create new chat: ${e.message}"
            Log.e("ChatViewModel", "Error creating new chat document: ${e.message}", e)
            _isLoading.value = false
        }
    }

    private fun listenForMessages() {
        // Ensure chatDocumentId is not null before listening
        val currentChatDocId = chatDocumentId ?: run {
            Log.w("ChatViewModel", "chatDocumentId is null, cannot listen for messages.")
            _isLoading.value = false
            return
        }

        messagesListener?.remove() // Remove any existing listener
        messagesListener = db.collection("chats")
            .document(currentChatDocId)
            .collection("messages")
            .orderBy("timestamp", Query.Direction.ASCENDING)
            .addSnapshotListener { snapshot, e ->
                if (e != null) {
                    Log.e("ChatViewModel", "Messages listen failed.", e)
                    _errorMessage.value = "Failed to load messages: ${e.message}"
                    _isLoading.value = false
                    return@addSnapshotListener
                }

                if (snapshot != null) {
                    val newMessages = snapshot.documents.mapNotNull { doc ->
                        doc.toObject(ChatMessage::class.java)?.copy(id = doc.id)
                    }
                    _messages.value = newMessages
                    _isLoading.value = false
                } else {
                    _isLoading.value = false
                    _messages.value = emptyList() // No messages yet
                }
            }
    }

    fun sendMessage(content: String) {
        if (content.isBlank() || chatDocumentId == null) return

        val message = ChatMessage(
            senderId = currentUserId,
            senderName = currentUserName,
            content = content.trim(),
            timestamp = Timestamp.now()
        )

        val currentChatDocId = chatDocumentId!! // We know it's not null here

        val chatRef = db.collection("chats")
            .document(currentChatDocId)
        val messagesRef = chatRef.collection("messages")

        viewModelScope.launch {
            try {
                db.runBatch { batch ->
                    // Add the message to the subcollection
                    val newMessageRef = messagesRef.document() // Auto-generate message ID
                    batch.set(newMessageRef, message)

                    // Update existing chat document's lastMessage and updatedAt
                    batch.update(
                        chatRef,
                        "updatedAt", Timestamp.now(),
                        "lastMessage", mapOf(
                            "senderId" to message.senderId,
                            "content" to message.content,
                            "timestamp" to message.timestamp
                        )
                    )
                }.await()

                Log.d("ChatViewModel", "Message sent and chat updated: ${message.content}")
                _errorMessage.value = null
            } catch (e: Exception) {
                Log.e("ChatViewModel", "Error sending message or updating chat document.", e)
                _errorMessage.value = "Failed to send message: ${e.message}"
            }
        }
    }

    override fun onCleared() {
        super.onCleared()
        messagesListener?.remove() // Remove the listener when the ViewModel is cleared
    }

    // ViewModel Factory
    class Factory(
        private val listingId: String,
        private val requestedParticipantIds: List<String>, // Use the list directly
        private val currentUserId: String,
        private val currentUserName: String,
        private val chatType: ChatType
    ) : ViewModelProvider.Factory {
        @Suppress("UNCHECKED_CAST")
        override fun <T : ViewModel> create(modelClass: Class<T>): T {
            if (modelClass.isAssignableFrom(ChatViewModel::class.java)) {
                return ChatViewModel(listingId, requestedParticipantIds, currentUserId, currentUserName, chatType) as T
            }
            throw IllegalArgumentException("Unknown ViewModel class")
        }
    }
}